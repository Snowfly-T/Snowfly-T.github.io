<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>关于NotePad++作者辱华的一些评价</title>
    <link href="/2023/01/31/%E5%85%B3%E4%BA%8ENotePad-%E4%BD%9C%E8%80%85%E8%BE%B1%E5%8D%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%84%E4%BB%B7/"/>
    <url>/2023/01/31/%E5%85%B3%E4%BA%8ENotePad-%E4%BD%9C%E8%80%85%E8%BE%B1%E5%8D%8E%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AF%84%E4%BB%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="关于NotePad-作者辱华的一些评价"><a href="#关于NotePad-作者辱华的一些评价" class="headerlink" title="关于NotePad++作者辱华的一些评价"></a>关于NotePad++作者辱华的一些评价</h1><p>多年前NotePad++因作者辱华而许多人呼吁删除NP++时，我觉得无所谓，因为作者个人的政治观点不应影响我使用他自己的软件。React、Jenkins等一众软件或框架至今还在官网上挂着“支持乌克兰”的标语，也不影响我用它们，因为作者或团队自身的政治观点本身是与我使用他们开发的软件无关的。</p><p>但NP++的作者自从这两天宣布有意在代码中投毒，若使用者不符合他的政治观点就要在代码中插入随机字符，这就是两码事了。尽管之后NP++作者就宣称之前的话只是个玩笑，但只要有任何软件作者表达了类似的倾向，那么这一软件即使再好也不应该使用了。这并非政治问题，而是若一个人以这样不负责任的态度对待自己的代码，那他就什么事都可能做得出来，而这个作者未来开发的任何软件也变得不可信了。即使NP++的作者宣布要为美国用户而不是中国用户投毒，我也不会再使用它了，至少我不会。这也是为什么现在很多政府单位不再敢于使用AntD了，因为AntD之前出了一起圣诞节菜单事件，而这事没在文档中写明，属于严重的欺瞒行为，甚至已经近似于代码投毒。</p><p>社区对任何开源项目的信任都来源于对作者自身责任心的信任，当这一点受到质疑，那么对于该作者的任何作品都不该抱有信任。社区便是如此，也应当如此。这无关政治态度。即使某一天有位国内开发者开发了某个被广泛使用的软件，然后某一天宣布要给美国用户“一点颜色看看”，我也会不会有任何开心，而是会立即停用该软件，因为这表明我不再能信任此作者的责任心。这无关政治态度。</p><p>当然NP++现在本来就不是很好用了，即使寻找平替Sublime Text也显然更好一些。我个人也早就不用了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Nginx部署SPA的现代方法</title>
    <link href="/2022/12/15/Nginx%E9%83%A8%E7%BD%B2SPA%E7%9A%84%E7%8E%B0%E4%BB%A3%E6%96%B9%E6%B3%95/"/>
    <url>/2022/12/15/Nginx%E9%83%A8%E7%BD%B2SPA%E7%9A%84%E7%8E%B0%E4%BB%A3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Nginx部署SPA的现代方法"><a href="#Nginx部署SPA的现代方法" class="headerlink" title="Nginx部署SPA的现代方法"></a>Nginx部署SPA的现代方法</h1><p>关于nginx部署SPA（单页应用）查了很多资料，但发现都过时严重，而且方法不够简洁明了。实际上现在nginx部署SPA的步骤很简单，没有很多教程写得那么复杂。</p><p>以Ubuntu为例（因为看到了太多CentOS的教程，这里就拿Ubuntu演示下，俩系统除了文件夹名有点区别外其他都一样）</p><p>首先安装nginx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo apt update<br>$ sudo apt upgrade<br>$ sudo apt install nginx<br></code></pre></td></tr></table></figure><p>然后进入nginx的配置目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /etc/nginx<br></code></pre></td></tr></table></figure><p>创建html文件夹，过会儿我们的静态文件就放在这里。当然你也可以随便起个别的名字，或者之后指定到别的文件夹上。选择将静态文件放在nginx配置文件目录里主要是为了避免之后可能出现的nginx权限不够的问题。如果你想把静态文件放在其他目录中，比如<code>/www</code>中，nginx一般来说默认是没有访问该文件夹的权限的，此时需要手动给这个文件夹赋一下权限，比如<code>chmod -R 777 /www</code>。当然，我们这里直接在nginx目录下放静态文件，不用管这事儿。</p><p>然后进入<code>/etc/nginx/conf.d</code>文件夹。</p><p>创建<code>default.conf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ vi default.conf<br></code></pre></td></tr></table></figure><p>然后粘贴以下内容</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs awk">server &#123;<br>        <span class="hljs-comment"># 监听端口，一般就是80，这也是网页访问时的默认端口</span><br>        listen <span class="hljs-number">80</span>;<br>        <span class="hljs-comment"># server_name是你的服务器地址，ip或网址都行</span><br>        <span class="hljs-comment"># 注意不要写localhost，因为这个地址是外网访问时的地址</span><br>        <span class="hljs-comment"># 除非你就打算在局域网访问，那么写localhost确实没问题</span><br>        server_name www.example.com;<br><br>        location / &#123;<br>                <span class="hljs-comment"># alias是静态文件所在的文件夹</span><br>                <span class="hljs-comment"># 由于打算将静态文件放在/etc/nginx/html目录下，</span><br>                <span class="hljs-comment"># 所以这里也这么写</span><br>                <span class="hljs-comment"># 有很多教程这里使用root + try_files</span><br>                <span class="hljs-comment"># 这其实是不合适的，root本身就不是给单页应用使用的</span><br>                <span class="hljs-comment"># 使用alias更合适</span><br>                alias <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/html/</span>;<br>                index index.html index.htm;<br>        &#125;<br><br>        <span class="hljs-comment"># 如果你的应用采用了将请求转发的方式（很多框架和模板都会这么干）</span><br>        <span class="hljs-comment"># 那么需要在nginx上设置一下代理</span><br>        <span class="hljs-comment"># 比如这里假设该网页的后端就部署在这个服务器上，端口是8081</span><br>        <span class="hljs-comment"># 然后SPA自身配置的是把请求都转发到/api/...上</span><br>        <span class="hljs-comment"># 根据实际情况，这里的location可能会是/prod-api/等其他形式</span><br>        <span class="hljs-comment"># 如果实在搞不清楚这里该代理啥，就先把网页部署上去，按F12看看请求报错信息</span><br>        <span class="hljs-comment"># 就知道请求的是哪个地址了</span><br>        location <span class="hljs-regexp">/api/</span> &#123;<br>                proxy_pass http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8081</span>/;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后保存</p><p>别忘了把静态文件传到刚刚创建的html文件夹下，这里就把这步骤省略了</p><p>然后检查一下配置文件有没有语法错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ nginx -t<br></code></pre></td></tr></table></figure><p>然后输入以下命令重载配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ nginx -s reload<br></code></pre></td></tr></table></figure><p>然后就结束了</p><p>然后说明一下为啥改的是<code>conf.d/default.conf</code>而不是<code>nginx.conf</code>。很多教程都是改的<code>nginx.conf</code>，这其实一点也没错，但<code>nginx.conf</code>内容比较多，改的时候容易眼花改错。而<code>nginx.conf</code>默认是把<code>conf.d/</code>目录下的配置文件都加载进去的，所以直接在这个目录下创建配置文件就好了，改起来更清楚和方便。顺便只要配置文件是<code>.conf</code>结尾的就会被读进去，叫不叫<code>default</code>其实无所谓。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Vultr自建梯子流程（使用V2Ray）</title>
    <link href="/2022/12/01/Vultr%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8V2Ray%EF%BC%89/"/>
    <url>/2022/12/01/Vultr%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8V2Ray%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Vultr自建梯子流程（使用V2Ray）"><a href="#Vultr自建梯子流程（使用V2Ray）" class="headerlink" title="Vultr自建梯子流程（使用V2Ray）"></a>Vultr自建梯子流程（使用V2Ray）</h1><p>最近使用了很久的梯子崩了，连续崩了好几天，也不知道是不是跑路了，只剩下手机上有个备用的免费梯子能用。由于经历了多次类似的事情，生怕再发生这样的事情，想来想去还是自己的梯子最踏实，于是花了点时间拿VPS搭了一个，也不知道能用多久。在搭梯子期间踩了不少坑，就记录一下搭梯子的全流程，权当做个备忘。</p><p>首先去<a href="https://www.vultr.com/">Vultr</a>上买个VPS，充10美金就行，Paypal支付宝等都支持，关于注册Vultr和如何充钱就不过多赘述了。</p><p>然后进入<a href="https://my.vultr.com/%EF%BC%8C%E5%A6%82%E5%9B%BE">https://my.vultr.com/，如图</a></p><p><img src="/img/Vultr%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8V2Ray%EF%BC%89/01.png"></p><p>点击<code>Deploy Server</code>，部署服务器。</p><p>这里的服务器配置如下面几张图所示：</p><p><img src="/img/Vultr%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8V2Ray%EF%BC%89/02.png"></p><p><img src="/img/Vultr%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8V2Ray%EF%BC%89/03.png"></p><p><img src="/img/Vultr%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8V2Ray%EF%BC%89/04.png"></p><p><img src="/img/Vultr%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8V2Ray%EF%BC%89/05.png"></p><p><img src="/img/Vultr%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8V2Ray%EF%BC%89/06.png"></p><p>如上所示，这里选择最低配版本的Cloud Compute型、Intel Regular Performance CPU &amp; Storage、25G SSD，然后关掉了自动备份（Auto Backups）。除此之外，系统选择了CentOS 7，服务器地址这里选择了印度孟买。</p><p>个人测试下来东京、印度的几个城市、新加坡这几个地方的服务器都是可以ping通的，其中东京服务器的速度最快。这里不选东京的主要原因是东京的服务器虽然ping得快但似乎不太稳定，所以这次就不用东京的服务器了。自用的话可以多创建几个服务器机房在不同位置的VPS试试看，Vultr上的VPS随时可以销毁掉然后重新建个新的，并且由于是按时计费，这么做不会带来额外的成本。</p><p><img src="/img/Vultr%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8V2Ray%EF%BC%89/07.png"></p><p>最后看到这样一台最低配的VPS的月租是5美金，每小时$0.007，点击Deploy Now立即部署。</p><p>然后在Products页能看到VPS正在分配</p><p><img src="/img/Vultr%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8V2Ray%EF%BC%89/08.png"></p><p>初始化完成后看到Status变成了Running</p><p><img src="/img/Vultr%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8V2Ray%EF%BC%89/09.png"></p><p>点进去就可以看到服务器信息了</p><p><img src="/img/Vultr%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8V2Ray%EF%BC%89/10.png"></p><p>不过这时候服务器大概率还在初始化，因此大概还需要等十几分钟才能用ssh连上去，所以先等一会儿再继续。如果嫌等待时间太长也可以在之前选一个更好的CPU &amp; Storage，每个月多加1美金（也就是一共6美金&#x2F;月），服务器会流畅点。</p><p>然后启动自己电脑上的终端，使用ssh登录服务器，输入下面的命令（<code>&lt;ip&gt;</code>请替换成自己的服务器IP）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh root@&lt;ip&gt;<br></code></pre></td></tr></table></figure><p>我这里使用Windows PowerShell，终端使用的是Win11自带的Windows Terminal。如果用Win10发现系统不自带Windows Terminal也可以直接在Windows Store里下一个（就叫做“终端”）</p><p>然后按照提示接受fingerprint，并输入Vultr上的初始密码（在Product页可以找到）</p><p><img src="/img/Vultr%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8V2Ray%EF%BC%89/11.png"></p><blockquote><p>如果你在这里接受fingerprint时失败，可能是由于你在反复销毁创建VPS的过程中分配到了同一个IP，由于你的电脑上已经存在了旧VPS的fingerprint，因此无法接受同一个IP的新VPS的fingerprint</p><p>此时只需简单输入下面的命令清除旧fingerprint即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -R &lt;ip&gt;<br></code></pre></td></tr></table></figure></blockquote><p>为了方便起见，先使用passwd命令改一下密码，然后reboot重启服务器以生效，毕竟每次去输初始密码很麻烦</p><p>再使用ssh连上服务器，这次用修改后的密码</p><p><img src="/img/Vultr%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8V2Ray%EF%BC%89/12.png"></p><p>然后输入以下命令进入V2Ray安装脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bash &lt;(curl -s -L https://git.io/v2ray.sh)<br></code></pre></td></tr></table></figure><p><img src="/img/Vultr%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8V2Ray%EF%BC%89/13.png"></p><p>输入1安装，然后不断回车使用默认设置即可</p><p><img src="/img/Vultr%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8V2Ray%EF%BC%89/14.png"></p><p>继续按回车确认，然后等待几十秒安装完毕</p><p>安装完成后的界面大致如下</p><p><img src="/img/Vultr%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8V2Ray%EF%BC%89/15.png"></p><p>安装完成后别忘了在防火墙上打开对应的端口。输入以下指令，将<code>&lt;port&gt;</code>替换为上面显示的端口号，如这里就是54766（<strong>这一步很重要</strong>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">iptables -I INPUT -p tcp --dport &lt;port&gt; -j ACCEPT<br></code></pre></td></tr></table></figure><p>然后输入下面的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">v2ray url<br></code></pre></td></tr></table></figure><p><img src="/img/Vultr%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8V2Ray%EF%BC%89/16.png"></p><p>复制终端显示的vmess url</p><p>然后在自己的电脑上下载v2rayN（即客户端）：<a href="https://github.com/2dust/v2rayN/releases/tag/5.38">https://github.com/2dust/v2rayN/releases/tag/5.38</a></p><blockquote><p>如果你在电脑上安装了Scoop，也可以直接在命令行输入以下命令直接安装v2rayN。如果你未安装Scoop，忽略这条提示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scoop install v2rayn<br></code></pre></td></tr></table></figure></blockquote><p><img src="/img/Vultr%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8V2Ray%EF%BC%89/17.png"></p><p>选择下载v2rayN-Core.zip，解压缩后打开，界面大致如下</p><p><img src="/img/Vultr%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8V2Ray%EF%BC%89/18.png"></p><p>选择服务器-&gt;从剪贴板导入批量URL</p><p><img src="/img/Vultr%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8V2Ray%EF%BC%89/19.png"></p><p>可以看到导入成功</p><p><img src="/img/Vultr%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8V2Ray%EF%BC%89/20.png"></p><p>然后右键托盘上的v2rayN图标，选择系统代理-&gt;自动配置系统代理。路由设置为绕过大陆（一般默认就是这个选项）</p><p><img src="/img/Vultr%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8V2Ray%EF%BC%89/21.png"></p><p>此时应当就能正常访问外网了，这里使用Google测试</p><p><img src="/img/Vultr%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8V2Ray%EF%BC%89/22.png"></p><p>可以看到访问正常，Google上地区显示印度，正好就是我们VPS所在服务器机房的位置，说明梯子搭建成功</p><blockquote><p>顺带一提，v2rayN有个很有趣的功能。如果你在Windows系统上安装了一些UWP应用，会发现这些应用即使开了梯子也没法连接外网，这是因为UWP应用在沙盒中运行，无法直接使用代理</p><p>而v2rayN自带一个小工具可以解决这个问题。在设置-&gt;参数设置-&gt;v2rayN设置中，点击“解除Win10 UWP应用回环代理限制”，全选然后点击“Save Changes”，即可让UWP应用正常使用代理</p><p><img src="/img/Vultr%E8%87%AA%E5%BB%BA%E6%A2%AF%E5%AD%90%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BD%BF%E7%94%A8V2Ray%EF%BC%89/23.png"></p></blockquote><p>在手机上访问梯子同理，只是需要安装v2rayNG，和v2rayN的使用大同小异，这里就不赘述了</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于Web 3.0——炒作、思考与批判</title>
    <link href="/2022/07/29/%E5%85%B3%E4%BA%8EWeb-3-0%E2%80%94%E2%80%94%E7%82%92%E4%BD%9C%E3%80%81%E6%80%9D%E8%80%83%E4%B8%8E%E6%89%B9%E5%88%A4/"/>
    <url>/2022/07/29/%E5%85%B3%E4%BA%8EWeb-3-0%E2%80%94%E2%80%94%E7%82%92%E4%BD%9C%E3%80%81%E6%80%9D%E8%80%83%E4%B8%8E%E6%89%B9%E5%88%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="关于Web-3-0——炒作、思考与批判"><a href="#关于Web-3-0——炒作、思考与批判" class="headerlink" title="关于Web 3.0——炒作、思考与批判"></a>关于Web 3.0——炒作、思考与批判</h1><p>Web 3.0在近年来正逐渐变得越来越火。必须承认，Web 3.0获得如此之高的热度绝大部分要归功于区块链炒作，尤其是NFT与元宇宙。</p><p>我最近看到有一些资料颠倒了这层先后关系，严肃地斥责“Web 3.0的概念被元宇宙炒作污染了”，并认为“真正的Web 3.0与这些炒作几乎毫无关系”。这话既正确又错误。因为目前常提及的Web 3.0概念本身就是由以太坊联合创始人之一Gavin Wood提出的：“Web 3（或称Web 3.0）是一种新的万维网迭代理念，它融合了去中心化、区块链技术及代币经济学等概念。”请注意，这里的Web 3.0原本是“Web 3”，只是后来被人误称为“Web 3.0”，而许多人并未搞清楚两者的区别，于是“Web 3.0”逐渐成为了“Web 3”的一个别称。</p><p>那么Web 3.0的原义又是什么？要谈起Web 3.0，最早要追溯到“Web 2.0”。Web 2.0这个词汇最早于1999年由Darcy DiNucci创造，后来于2004年在O’Reilly公司举行的Web 2.0会议上被推广。Web 2.0即“内容互联网”，指在互联网泡沫破裂后反而涌现了一大批更注重交互式的网站，它们更注重交互性而非由网站管理者主导一切，一个很典型的例子就是大英百科全书（Web 1.0）与维基百科（Web 2.0）的对比。</p><p>既然有了Web 2.0，很快人们就会开始想象什么是Web 3.0。“Web 3.0”这个词语的最初出现已经不可考，或者说既然有了Web 2.0，那自然而然地提出Web 3.0的概念简直毫无难度。大约在2006年初，于中外各学术网站上就开始陆续出现Web 3.0的说法，那么几乎可以肯定Web 3.0这个词语被提及至少在2005年就已经开始，甚至是在Web 2.0这个概念刚开始流行的2004年。</p><p>Web 3.0这个词语真正流行起来和“语义网”有很大关联。2006年，语义网概念的提出者Berners Lee谈到Web 3.0时，提到“人们反复询问Web 3.0是什么样子，我认为也许当你能够在Web 2.0上见到可缩放矢量图形（SVG）的大规模使用——互联网上的一切都像水中的涟漪一样相互关联与叠加、看不到确切的边界——与一张巨大的、涵盖大量数据的语义网时，你就能访问互联网上这些难以置信的海量数据资源了……”这可能是Berners Lee自2001年提出“语义网”该年以来第一次将其与“Web 3.0”关联起来。自此之后，“Web 3.0”某种意义上成为了“语义网”的一种别称——正如现在“Web 3.0”多数时候作为“去中心化互联网”的代称一样。</p><p>然而我们这些年似乎很少看到“语义网”这一概念了，甚至许多人从未听说过这个词汇。“语义网”其实是个非常简单的想法，即令网站不仅是“人类可读”的，而且也是“机器可读”的。换句话说，网站通常只是将信息以文字或图片形式发布给人类阅读，那为什么不为网站提供一些额外的信息，使得机器也能理解网站上包括了什么内容呢？例如，一个介绍某地区，如中国某个省份的网站可以附加一些额外信息，指出这是一个“地方网站”，而这些附加信息也指出其位于“中国”这个国家，而“中国”又位于“亚洲”这个大洲。如此一来，该网站就可以和介绍中国的网站、介绍亚洲的网站产生关联（如果这些网站也添加了类似的描述信息的话）。从而，机器就可以将这些网站组成一张“网”。</p><p>上面所举的简单例子可能不足以让你认识到“语义网”的野心。考虑这样一个场景，当你需要搜索某个作者的图书时，例如“鲁迅文集”，你或许常常会找到一些不那么令你满意的搜索结果，比如“鲁迅简介”，“鲁迅文集的历史地位”等网页。显然，你的意图应该是找到鲁迅具体写了哪些书，以及这些书的内容，但遗憾的是搜索引擎无法完美理解你的意思。然而，语义网可以给这些网站标注相关信息，这样搜索引擎就可以分辨哪些网页是“图书内容”，哪些又仅仅是无关的诸如“作者简介”的内容。甚至若这些附加信息更加详细，语义网还可以分辨出哪些是书籍前言、哪些是导引，而哪些又是正文。</p><p>听起来有点像“自然语言理解（NLU）”？的确，语义网的实现显然需要NLU方面的技术。在理想情况下，你可以直接告诉语义网，“我想要一张明天早上九点从北京飞往上海的机票”，然后语义网可以自动找到相关的机票网站，帮你筛选符合要求的航班，并且自动订票。</p><p>好吧，这个例子可能听起来不那么美好——毕竟现在网上订票，也不过就是在网站上点几下鼠标的事情，而且现在其实已经有一些语音助手可以做到类似的事情了。但在语义网刚提出的那段时间，订机票可是一项复杂的事情，需要筛选时间表、联系航空公司，然后还要预约时间让相关人员送票上门。而且语义网似乎是可行的，只要为每个网站提供那么些附加信息，机器就能理解每个网站在做什么，将它们联系在一起，并且通过某种途径达成“智能”。</p><p>“语义网”正如字面意义一样，你可以直接通过自然语言达成你想达成的目的，有点类似于现在火热的“人工智能”概念。不过后来，“语义网”概念的提出者Berners Lee认为“语义网”这个说法有些不太准确，毕竟语义网本质上还是通过为网站附加信息而达成目标，将不同网站连成一个“网”的，将其称为“数据网”可能更加合适一些。</p><p>然而正如大家现在看到的，“语义网”至今没见到什么靠谱的实现，而且人们严重低估了其实现难度，光是要使机器理解自然语言就是一件非常困难的事情，更别提让机器理解错综复杂的网络关系了。是不是有点像现在“Web 3.0”中的“元宇宙”概念？听起来未免有些过于自大与不切实际了。</p><p>后来，“语义网”确实产生了一些结果，例如RDF数据模型，这是一种旨在为全网数据交换而设计的模型，可以视作上面提到的“附加信息”的具体实现。然而，RDF最大的成果并不在于它对语义网做出了多么巨大的贡献，而是它的三元存储数据模型启发了很多其他三元存储查询语言的出现，这些模型在图数据库中大获成功。某种意义上，“语义网”产生的这些成果确实应用了到了它最初设想的领域上，这些图数据库现在广泛应用于社交网络中，例如推特就使用类似的数据结构维护用户之间的关系。遗憾的是，“语义网”并没有实现“全网互联”，顶多只能说它的某些成果为社交网络上的“用户互联”提供了帮助。</p><p>为什么要花这么大的篇幅介绍“语义网”这个“旧”Web 3.0，而不是现在以“元宇宙”为热点的“新”Web 3.0？可以看到，实际上现在的“元宇宙”和当初的“语义网”在某种意义上非常相似，提出了一个现阶段难以被实现，甚至在理论上都缺乏有力支撑的概念。它的野心很大，其边界又非常模糊，好像要“革命互联网”，但又没提出具体要如何“革命”，只是拿来现在一些潮流的新技术名词往上堆砌，就称其为“元宇宙”，称其为“Web 3.0”。</p><p>其实现在的“Web 3.0”指向模糊不是最大的问题。当年Web 2.0被提出时，也被人批评“更近似一个炒作概念”。但Web 2.0被提出时，诸如博客、维基百科等被认为属于“Web 2.0”的交互式网站已经在不断涌现，并且在以惊人地速度不断增长用户了。而Web 3.0包括了什么？区块链、元宇宙、VR、或是DeFi与代币经济学，听起来都是一些不错的概念，但它们目前除了金融炒作外，实际应用少得可怜。一直被拿来宣传“元宇宙”的Roblex，其实只是个更具社交性的小游戏平台。而VRChat，也只是曾红极一时的VR技术的延续，再加上了一些社交功能而已。或许未来如Roblex这样的平台不再仅仅是当前简陋的小游戏平台，而VRChat这样的平台也可以使人们在某种意义上真正“度过一段虚拟世界的生活”。但在如此早期的阶段就大肆吹捧所谓“元宇宙”，将其称为“互联网的下一个阶段——Web 3.0”，实在是有些太早了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>“Only One Book”计划（计算机理论类，非TCS）</title>
    <link href="/2022/07/06/Only-One-Book%E8%AE%A1%E5%88%92%EF%BC%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E7%B1%BB%EF%BC%8C%E9%9D%9ETCS%EF%BC%89/"/>
    <url>/2022/07/06/Only-One-Book%E8%AE%A1%E5%88%92%EF%BC%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%90%86%E8%AE%BA%E7%B1%BB%EF%BC%8C%E9%9D%9ETCS%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="“Only-One-Book”计划（计算机理论类，非TCS）"><a href="#“Only-One-Book”计划（计算机理论类，非TCS）" class="headerlink" title="“Only One Book”计划（计算机理论类，非TCS）"></a>“Only One Book”计划（计算机理论类，非TCS）</h1><p>近年来专业书籍，尤其是计算机类的专业书籍成井喷式增长。在过去这类书也一点不少，但大多是出版社出来骗钱的，能看的没几本，大家公认值得看的书也屈指可数。然而现在情况似乎有些不同了，新一批技术书籍无论是质量还是数量都相比过去有了很大进步，甚至经常出现同一领域有十几本面向读者相差不大的书，且风评都很不错。此外，国产技术书的水平也有显著提升。这固然是好事，但也带来了一些“幸福的烦恼”，那就是选书时往往容易无从下手。</p><p>在这样的情况下，我决定以身试毒，给出一份“每个领域一本书”的书单，尽可能不使书中出现太多重复内容，浪费大家时间。即使几本书之间有重复的内容，我也尽量指出哪些部分不用看。我试图总结出一条当前合适且快速的学习路径，尽可能使读者吸收最有价值的内容。</p><p>*注：CSAPP是很好的一本书，但我并未将它放在书单中。这主要是由于CSAPP大杂烩式的风格导致它既难以归类到导论性质的书中，又难以归类到任何深入讲解某一领域知识的书中。如果归类到导论中，CSAPP未免太厚了，如果归类到计组计网操作系统类的书中，CSAPP在某些层面上又似乎不够深入，因此我并未将其放入该书单。但CSAPP是一本适合你在学习的任何阶段都抽空读上一点的书，读它总会有不同的收获。没把CSAPP放在这里不是说明它不重要。</p><p>我将把整套学习路径分为理论和应用两大类，并尽可能让书单安排的顺序循序渐进，比如计组的书单会安排在操作系统前面。但有一些类别的知识并不互相构成前置关系，比如前端和后端就不存在哪个为前置，这时它们的安排顺序就是随机的。但对于任何涉及前置知识的书单，我都会将前置显式标明出来。</p><h2 id="计算机导论"><a href="#计算机导论" class="headerlink" title="计算机导论"></a>计算机导论</h2><p><img src="https://img3.doubanio.com/view/subject/l/public/s33656060.jpg" alt="img"></p><p><strong>中文书名</strong>：计算机科学导论</p><p><strong>英文书名</strong>：Foundations of Computer Science</p><p><strong>前置知识</strong>：无</p><p>正如书名所示，这是一本“导论”书。几乎任何学校的计算机科学与技术专业都会在大一开设一门“计算机导论”。简单来说，导论就是大杂烩，把大多数计算机领域都简要给你介绍一遍，但都不深入。然而，<strong>在你有时间的情况下</strong>，学习一下导论是很有意义的。它可以帮助你很好地树立起系统的计算机概念，帮助你在后续各个领域的学习中很轻松地入门，而非在哪门课最初一段时间的学习中感到困惑。</p><p>不过，<strong>导论并不是你一定需要先学习的</strong>。<strong>如果你时间紧急，可以直接跳过导论</strong>，我建议你可以直接开始数据结构与算法的学习。另外，导论中确实有一些部分不是你必须要阅读的，例如社交媒体导论，在多数情况下就是不需要阅读的。<em>但我还是建议有时间尽可能读一遍，这花不了太多时间，而且会给你带来宝贵的计算机领域“常识”。</em></p><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><p><img src="https://img2.doubanio.com/view/subject/l/public/s29107491.jpg" alt="img"></p><p><strong>中文书名</strong>：算法</p><p><strong>英文书名</strong>：Algorithms</p><p><strong>前置知识</strong>：任何一门编程语言的基础知识</p><p>正如其朴素的书名一样，这是一本算法书——一本完完全全的“<strong>算法</strong>”书，而不是“<strong>算法分析与设计</strong>”这些课程的参考书。</p><p>说到算法，我相信很多人第一个想到的书是MIT的《算法导论》。不得不承认，直到今天《算法导论》仍是算法分析领域最权威的参考书之一。注意到了吗？我说的是“算法分析”而非“算法”，实际上前者更偏向一门数学课，会涉及较多的时间复杂度分析，而后者则偏向实用。而在当前，除非你需要做一些颇为深入的理论研究，否则学习“算法分析”并不能给你太多实际的帮助。各大公司所谓“算法知识”，要求的自然也是“数据结构与算法”方面的知识。而这里推荐的《算法》被公认为数据结构与算法最好的入门书之一，也有很多人认为这是当前最好的算法入门书。</p><p>本书演示算法使用的语言是Java——这可能令一些人感到意外和疑虑。“如果我从未学过Java，是不是说我需要先学点Java才能看这本书？”，我的回答是，这本书几乎不需要你拥有Java基础，也许仅需的一点基础你在类似<a href="https://www.runoob.com/java/java-tutorial.html">菜鸟教程</a>这样的网站上简单翻阅前面的一点内容就够了。</p><p>为了照顾到使用其他语言的读者，这本书尽可能使用了一个有些特别的封装库，使代码看起来更易懂、更通用，例如使用自定义的标准输入&#x2F;输出类“StdIn&#x2F;StdOut”来代替Java中的Scanner与System.out，并且很少使用较为深入的Java特性，我认为只要读者有部分C&#x2F;C++甚至Python基础，要理解其中的代码都不会有很大难度。甚至即使你不打算学习任何有关Java的知识，直接开始阅读这本书，前面也花了一些篇幅大致介绍了Java语言，如果你打算直接靠这些较少的介绍入门Java可能会稍显吃力，但应该也大致足够。</p><p><em>其实我个人认为<strong>可以不考虑安装书中提供的自定义标准库</strong>，毕竟对于初学者而言，这可能也是一个劝退要素之一。考虑到Java环境的配置本来就不那么容易，还要引入一个标准库或许更容易让初学者头晕。因此，我建议直接使用Java内置的Scanner和System.out代替书中的StdIn和StdOut，你可以很容易找到如何使用它们。然而，书中使用的绘图库就不太容易使用原生Java直接模拟了，但考虑到绘图本身只是帮助理解，而非绝对必要的，你可以跳过那些要求你使用绘图库完成的习题。</em></p><p>也可能有人会问，“为什么《算法》不像《算法导论》一样使用伪代码描述？”，这是因为本书希望书中的所有代码都是可运行的，读者也可以根据课后习题编写可以实际调试运行的代码。如果你确实不喜欢Java，也可以尝试着用自己喜欢的语言，例如C++或是Python，重写书中的一些代码并完成课后习题，几乎所有习题都不对你具体使用哪门编程语言有限制。<strong>书中的代码都非常容易看懂，且附以大量用于描述的图片和表格，即使你一行实际的Java代码也不曾实际运行过，想看明白书中描述的各种数据结构和算法也是非常轻松的</strong>。你也可以很容易找到本书使用各种语言重写的代码和课后习题参考。读过这本书的人很多，资料自然也非常多。顺带一提，如果你不打算学习Java，那么第一章中的大部分内容可以跳着读。</p><p>另外，需要指出的一点是，算法的学习并非读完一本书就足够了。更重要的是时常去做相关习题，例如在LeetCode上刷算法题。读书只是开了个头，想指望靠读本书就通过各大公司的面试是不可能的。想要熟练掌握算法，不刷题肯定还是不行的。</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><img src="https://img1.doubanio.com/view/subject/l/public/s33936669.jpg" alt="img"></p><p><strong>中文书名</strong>：数据库系统概念</p><p><strong>英文书名</strong>：Database System Concepts</p><p><strong>前置知识</strong>：数据结构与算法</p><p>数据库知识的学习并没有太多前置知识要求，将对数据库的学习放在学完数据结构与算法后的任何阶段都是合适的。有些学习路径会将其安排在学完操作系统之后，这也没什么问题。本书单将数据库安排在算法之后的原因是，下面对计算机硬件知识的学习涉及的算法知识较少，但算法学习非常需要巩固，直接开始学习硬件很容易忘记刚学习的很多算法知识。而数据库这门课程对算法知识的涉及很多（尤其是在文件系统与查询处理部分），学习数据库的过程中也能顺带巩固一下算法知识，因此这么安排。</p><p>数据库领域没有太多读物可以推荐，基本上入门数据库都推荐这本《数据库系统概念》，本书单也遵循传统，推荐这本巨著。书中不仅包含了最基本的SQL语句、ER图设计、数据库范式、文件系统、查询处理与查询优化、并发与恢复等一切数据库课程都应该教授的基本内容，也包括了一些实用且前沿的内容，例如关系式数据库、分布式数据库、大数据与数据挖掘。在云原生的时代，《数据库系统概念》也与时俱进，毫不过时。然而，正如下面会提到的，如果你对书中一些前沿的内容不感兴趣，只想学点最通用的基础，那么可以考虑选购“本科教学版”。</p><p>在我个人看来，将对数据库的学习安排在前面还有个好处，就是能够与之后对操作系统知识的学习产生共鸣。在文件系统和索引部分，你可以了解到数据库如何为了提高文件读写性能而绞尽脑汁，而其中的一些思路与操作系统所采用的一些通用解决方法不谋而合。同理，在阅读事务管理部分时，你可以看到数据库如何为了保证原子性而考虑并发控制（锁），而操作系统的并发部分与之非常相似。而如果你第一次接触这些概念是在学习操作系统而非数据库时，也许会因为缺少一些更为实际的例子而难以体会这些概念的重要性。</p><p>值得注意的是，《数据库系统概念》这本书中文版将近800页，如果你感到自己很难啃下这么厚一本书，或许可以考虑阅读“本科教学版”，它只有不到500页。“本科教学版”相比原版删去了关系代数、复杂数据类型、大数据与数据分析、RAID、并行与分布式这几个部分，如果你对大数据与分布式数据库不那么感兴趣，“本科教学版”应当也足以提供完全足够的基础知识了。这里当然推荐你尽可能阅读原版，毕竟“本科教学版”删去的东西在如今看来还是相当重要的，然而如果你抱着一些功利性的目的学习数据库，例如打算通过面试或参加考试，不得不承认“本科教学版”也完全足够了。</p><h2 id="数字电路-amp-计算机系统"><a href="#数字电路-amp-计算机系统" class="headerlink" title="数字电路&amp;计算机系统"></a>数字电路&amp;计算机系统</h2><p><img src="https://img1.doubanio.com/view/subject/l/public/s33981898.jpg" alt="img"></p><p><strong>中文书名</strong>：计算机系统概论</p><p><strong>英文书名</strong>：Introduction to Computing Systems: From Bits &amp; Gates to C &amp; Beyond</p><p><strong>前置知识</strong>：无</p><p>有人可能会疑惑我为什么不直接推荐学习计组，而是要插入这样一本看起来有些奇怪的书。我们通常认为学习计组是正式学习计算机理论的开始，但是我既没有选择经典的CSAPP前四章，也没有选择广受好评的《计算机组成与设计 硬件&#x2F;软件接口》，而是选择了耶鲁大学的这本《计算机系统概论》。</p><p>这并非一本严格意义上的计组教材，尽管它和计组有一些关系，但这也不是一本能从标题看出其和计组有关的书。光看中文翻译，甚至可能产生这本书和操作系统有关的误解，只有当看到副标题“From Bits &amp; Gates to C &amp; Beyond”，你才会明白<strong>这是一本从二进制和逻辑门开始，一步步介绍计算机中程序运行逻辑的书</strong>。这本书集中于一步步带你了解计算机如何真正运行一段程序，因此许多和主题不那么相关的东西，比如SRAM和DRAM的区分，就不在这本书的讨论范围内了，因此这不是一本能代替计组教材的书。</p><p>选择这本书作为开始似乎有些多余，然而当我真正翻开这本书时，我才意识到一开始阅读这样一本书是多么重要。我想如果我在大一时就看过这本书，即使只看过一小半，应当也能受益匪浅。</p><p>我推荐它的一大原因是因为<strong>这本书几乎没有阅读门槛</strong>，非常适合通过这本书先一步对整个计算机理论体系进行一遍梳理。和计组有关的很多书都会大量涉及汇编或C语言，但却很少有篇幅认真介绍它们，这导致这些书往往需要一定的前置知识才容易看懂。而且，这些相关书籍中对C语言的要求不止局限于能够掌握基本语法，还要求对系统级API调用有一定了解，直接硬读这些书籍中的C语言代码，容易一知半解。而《计算机系统概论》这本书不同，<strong>它在大致介绍完硬件基础后，用了很大篇幅介绍C语言</strong>，更难能可贵的是这部分对C语言的介绍和前面讲解的硬件基础直接关联到一起，这种讲解方式让人很有启发。</p><p><em>你可能会认为需要一本如《C Primer Plus》或《C++ Primer》这样的书帮助你详细地了解C&#x2F;C++的相关知识。然而如果你未来不打算从事相关工作，读这些书很容易让你过度陷入语言细节。如果你的目的仅仅是使用C&#x2F;C++辅助理解计算机理论方面的知识，那么这本书应当已经完全足够了。</em></p><p>如果你有能力或者有挑战自己的想法，那么你可以尝试阅读这本书的第三版英文版，第三版出版于2019年，相比起2008年的第二版要新得多。你可以直接在国内买到英文版，也可以很容易地自行找到英文版电子版。不过对于大多数人来说，现在已有中文版的第二版也不算太过时，毕竟理论知识的过时速度非常缓慢（1984年的SICP还被奉为当代经典呢），如果你还是更偏爱中文版，稍旧一些的中文版第二版也可以阅读。</p><p><em>另外，你可能会对本书单中<strong>不包括模拟电路相关知识</strong>感到困惑。然而我实在不认为模拟电路对计算机理论的学习有多么重要，例如我很难想象在什么情况下学习计算机理论需要了解三极管原理，在我看来学习硬件知识止步于明白三极管&#x2F;MOS管可以起到开关作用就足够了，我们至多在逻辑门层面花些精力，将精力深入到晶体管层面就有些不太划算了。当然，这也仅仅是我的个人见解，如果你有异议，我也尊重你的意见，只是本书单确实就是按照我的想法安排的。</em></p><h2 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h2><p><img src="https://img2.doubanio.com/view/subject/l/public/s33707062.jpg" alt="img"></p><p><strong>中文书名</strong>：计算机组成与设计 硬件&#x2F;软件接口</p><p><strong>英文书名</strong>：Computer Organization and Design: The Hardware&#x2F;Software Interface</p><p><strong>前置知识</strong>：数字电路</p><p>事实上，在阅读完上面一本书后，学习计组对你实际编程能力的提升就不大了。我们常说计组很重要，说得其实严格来说不是计组，而是上面一本书中的计算机系统。只是通常来说，大部分人学习计算机系统都是通过学习计组搞明白的，而且几乎所有的计组资料中也包含了计算机系统的知识，因此我们通常将这两个概念混为一谈。</p><p>如果你不经常和底层硬件打交道，比如做驱动、设备协议这一块，你可能并不是很需要学习这方面的知识。<strong>上一本书中学到的所有知识已经足够你进入下一个学习阶段，也就是操作系统的学习了</strong>。毕竟在操作系统涉及的系统级编程中，你也只需要考虑寄存器、cache、主存等概念，不需要考虑计组中会涉及的诸如SRAM和DRAM的硬件区分等问题——你只需要了解cache比主存更快就可以了，至于它们的硬件逻辑，又和你有什么关系呢？然而问题在于，<strong>很多人学习计组是为了应付一些更现实的问题，比如本科课程考试或研究生考试，这种情况下你就不得不学习一些更深入的计组知识了</strong>。</p><p>在这里我推荐经典的《计算机组成与设计 硬件&#x2F;软件接口》。在计组领域，这应当是最经典的作品之一了（实际上，计算机体系结构的一些知识也为这本书的厚度做出了很大贡献，这并不是一本纯粹教授计组的书），在国内这更是首选。如果你正在学习计组相关的课程，不妨买一本拿来参考一下，或许比你的老师讲得更好。</p><p>值得注意的是，<strong>这本书很大一部分内容和上一本书有重叠</strong>。如果你已经阅读了上面一本书（如果你确实在跟着本书单走，也应该把上面一本书读完了），那么这本书的大多数内容可以略读，你只需要认真阅读那些让你感到陌生的知识。</p><p>至于大家推荐的CSAPP，我仍考虑将它当作论外处理，建议作为一本“有时间翻翻”的读物，毕竟这本书究竟要归类到哪个领域我至今还难以下定论。有人说CSAPP的前四章也很适合作为计组教材，确实如此，但我想还是在这里放一本更专注于计组的书更加合适一些。</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p><img src="https://img9.doubanio.com/view/subject/l/public/s32332106.jpg" alt="img"></p><p><strong>中文书名</strong>：操作系统导论</p><p><strong>英文书名</strong>：Operating Systems: Three Easy Pieces</p><p><strong>前置知识</strong>：数据结构与算法；计算机硬件基本知识；C语言基本知识（至少应当了解至结构体与指针）</p><p>谈到操作系统，也许有人会推荐《现代操作系统》，然而当前这本更新的《操作系统导论》（一般简称os-tep）会更好。考虑到《现代操作系统》深受逆天翻译毒害，导致中文版好多句子读起来非常别扭，相比之下《操作系统导论》是更为合适的选择（尽管翻译得也比较生硬，但总体可读，至少比《现代操作系统》好上很多）。顺带一提，个人认为邮电的《操作系统导论》的排版印刷质量也比属于机工社黑皮书系列的《现代操作系统》好上一些，纸张更好，字体更大，读起来不那么累，虽然稍贵一些，但阅读体验其实更好。</p><p>作为本就不容易过时的理论书籍，这本英文原版出版于2018年的书在一众理论书籍中看起来几乎崭新。你可以感受到作者尽可能让学习操作系统变得轻松。书名副标题的”Three Easy Parts”分别指虚拟化、并发与持久性。书中穿插着一些有趣的扩展知识和一些有趣的对话，使阅读体验相对轻松不少。课后作业以给出可运行Python脚本的形式指导读者通过探索式的方法学习，非常生动有趣。除此之外，书后也包含几个大项目可以练手，和大多数西方的专业计算机教材一样，配套资料非常齐全。</p><p>PS：这本书的很大一部分课后作业（编码）需要在UNIX环境下进行，其中绝大部分可以在Linux&#x2F;Mac OS环境下进行，少部分可以在Windows环境下进行。个人建议，如果使用Windows平台，可以考虑直接使用WSL2进行模拟，现在WSL2支持直接调用Windows本地的 VSCode写代码，使用起来应当不很困难，至少比装个Linux&#x2F;Unix更简单。另外，有一些用于演示的课后作业使用Python 2编写，如果你使用Python 3，需要将其中的print语句进行修改才能正常运行。具体来说，就是将<code>print &#39;a&#39;</code>改成<code>print()</code>，将<code>print &#39;&#39;</code>改成<code>print()</code>，<code>print &#39;a&#39;,</code>改成<code>print(&#39;a&#39;, end=&#39;&#39;)</code>，基本上这样就可以运行了。</p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p><img src="https://img1.doubanio.com/view/subject/l/public/s29825217.jpg" alt="img"></p><p><strong>中文书名</strong>：计算机网络 自顶向下方法</p><p><strong>英文书名</strong>：Computer Network: A Top-Down Approach</p><p><strong>前置知识</strong>：数据结构与算法；一些最基本的Python语法（如果你不想了解，也可以直接跳过书中极少数涉及Python代码的部分，但Python非常简单，学一点基础花不了你半个小时，所以为什么不学一学呢）</p><p>计算机网络是个较大的话题，在计算机的许多热门领域（如Web开发）中，计算机网络的重要性似乎也仅次于数据结构与算法。针对不同的需求，对于“计算机网络”这一主题也有许多不同的书籍推荐。然而为贯彻本书单的宗旨，这里还是只主要推荐一本书，即《计算机网络——自顶向下方法》。</p><p>“自顶向下”不是一个很常见的词语，但即使你从未见过它，也应该能够很容易地从字面意思猜出它的含义——从最顶层一步步讲解到底层知识。很多人第一次接触“自顶向下”这个词语可能就是在看到这本书的标题时。“自顶向下”听起来有些与众不同，毕竟在其他理论的教学上，往往遵从着“自底向上”的教学方式，如经典的“数字电路—计算机硬件—操作系统”路径。然而在计算机网络知识的教学上，“自顶向下”是个很不错的教学方法，读者并不从枯燥的硬件知识学起，而是一开始接触应用层（HTTP），然后一步步学到硬件知识，这可以更直观有趣地学习计算机网络的知识。</p><p>如果你觉得《自顶向下方法》这本书太过硬核（其实你不该这么觉得，毕竟本书单之前每本书都比它厚或差不多厚），你可以考虑读一读一本小书《网络是怎样连接的》，相比之下这本书更有趣味性一些，且基本也是按自顶向下的方式叙述的（严格来说是按照端到端的方式）。然而既然《网络是怎样连接的》这本书在本书单中被提到了，你也应该清楚这不是什么“通俗科普读物”，其实也是带点硬核的，读起来仍需要一些耐心。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>也许有人会发觉这里似乎缺少了一些重要的东西。编译原理去哪了？算法分析去哪了？这些当然是重要的。然而就我看来，这些并非是每个人都必要学习的。例如编译原理作为本科教学阶段综合难度最大的一门课，却是所有课程中实用度最低的一门，你也几乎很难在编译器开发之外的场景下找到它的应用，因而我不会在这里推荐任何有关的书籍。同理，算法分析甚至计算理论和信息论也是重要的，但我想除了理论计算机科学家，少有人需要掌握这方面的知识，因此我也不会在这些领域给出任何推荐书籍。</p><p>另一门重要的课是离散数学，然而本书单并未包含离散数学相关的书籍推荐。虽然很多时候讨论经典计算机理论课程只提到计组、计网、操作系统、数据结构、数据库这些课程，然而离散数学的重要性丝毫不亚于这些课程。在西方的传统离散数学教学中，会涉及数理逻辑、集合论、图论相关的知识（在中国，离散数学还通常包含简单抽象代数），而这些知识无论是对于数字电路、数据结构抑或是计算理论的学习都是很有帮助的。然而本书单并未包含离散数学的原因之一是其中很多内容已经渗入了各类课程中，例如许多经典的算法教材已经包含了本应在离散数学中学习的生成树概念，而数理逻辑的部分内容也常常被数字电路甚至计算机导论所包含，因此已经不很需要单独学习一门离散数学了。另一点是离散数学中大部分内容实际上是计算理论等课程的前置，而这些课程已经在本书单中删去，因此本书单自然也就不包含离散数学了。</p><p>如果有读者认为有必要打好一些离散数学的基础，那么可以考虑阅读左孝凌的《离散数学》，这是一本非常简洁的书，几乎用最少的语言较为清晰地描述了离散数学至少该教授的内容，唯一的缺点是出版时间距今已四十多年了，有些陈旧。有人会批评左孝凌这本书不够生动，但能在这么薄一本书中塞下能够让人读懂的解释与合适的习题，其实也实属不易了，不用过度苛求。另外，有些人可能会推荐Rosen的《离散数学及其应用》，我个人不推荐这本，这本书的厚度远远超出了学习基础理论知识所需要掌握的，更像一本“百科”而非入门书。</p><p>也许还有人会提到SICP——即《计算机程序的构造和解释》。这是一本非常经典的书，其中也有非常精妙的思想，你或许可以考虑在抽象能力遇到瓶颈时读一读。然而这本书不应该包含在这里提到的计算机理论学习路径中，也绝非必要的。我很难描述这是一本怎么样的书，我读完后只能告诉他人这是一本关于“抽象”这一概念本身的书，至于这本书具体讲了些什么，以我贫乏的表达能力很难总结出来。总之，SICP应当是一本在你对编程有了一些深入思考后阅读的书。有很多人将这本书抬到了不属于它的过高地位，经典的就是拿MIT拿这本书作为计算机科学专业第一门课举例，然而要知道MIT也早就将计算机科学专业的第一门课换成Python，并且把SICP作为选修课了。<strong>SICP绝对不适合作为一本入门书</strong>。它很重要，但它的重要性非常特别，它既没有被高估也没有被低估，但总有人将它放到不属于它的位置，这很不合适。至少就本书单来说，读者不需要考虑任何有关SICP的事，当前你只需要了解有这样一本书就可以了。</p><p>最后，还记得CSAPP吗？这可能是这里提到的所有书中最值得读的，但没有直接包含在本书单中，因为这本书涉及领域太广，实在是难以归类。显然，书单中没有直接包含CSAPP并不意味着它不值得读，相反，你其实可以在任何时候翻开CSAPP读一读，甚至在你已经学完这里提到的所有理论知识后，CSAPP也常常给人新的启发。</p><p>本书单的宗旨是总结出严格的“一条”路径。这条路径是循序渐进的、易于理解的，同时也应当是适用于绝大多数人的。本书单必然不可能照顾到少数领域的需求，例如量子计算领域、人工智能领域等。本书单只总结计算机这个大领域中几乎所有人都有必要掌握的知识。如果我像其他书单一样每个领域都推荐好几本书甚至十几本书，那恐怕只能让多数读者感到眼花缭乱。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于TIOBE编程语言排行榜……</title>
    <link href="/2022/07/06/%E5%85%B3%E4%BA%8ETIOBE%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%8E%92%E8%A1%8C%E6%A6%9C%E2%80%A6%E2%80%A6/"/>
    <url>/2022/07/06/%E5%85%B3%E4%BA%8ETIOBE%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%8E%92%E8%A1%8C%E6%A6%9C%E2%80%A6%E2%80%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="关于TIOBE编程语言排行榜……"><a href="#关于TIOBE编程语言排行榜……" class="headerlink" title="关于TIOBE编程语言排行榜……"></a>关于TIOBE编程语言排行榜……</h1><p><img src="/img/%E5%85%B3%E4%BA%8ETIOBE%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%8E%92%E8%A1%8C%E6%A6%9C%E2%80%A6%E2%80%A6/01.png"></p><p><img src="/img/%E5%85%B3%E4%BA%8ETIOBE%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E6%8E%92%E8%A1%8C%E6%A6%9C%E2%80%A6%E2%80%A6/02.png"></p><p>我有时候真的挺害怕有人被TIOBE排行榜误导，每当看到有哪个营销号拿TIOBE排行榜说某某某编程语言没落了，哪个编程语言又火了，我都能感到十分荒唐。要是谁真拿这种娱乐排行榜评判编程语言的流行程度，那简直是发疯。</p><p>TIOBE排行榜根本就是根据搜索引擎热度和网页数量自动生成的。比如C的排名高很大程度上是因为C是个简单的英文字母，就是一个教字母表的网页也会被当成是C语言网页统计进去。同理R和Go的排名显然也是虚高的。<br>就单说这个排行榜上最匪夷所思的一些排名吧。</p><ol><li>VB排名第6就很疯狂，就算这个排名包含了vb.net，可vb.net也已经不再更新，仅做维护了，况且vb.net根本没起来过，这排名结果应该主要是历史原因造成的</li><li>C#看起来也有些虚高，在与微软无关的领域C#几乎看不到应用，尽管这确实是门好语言</li><li>汇编排在Swift上边只能说或许是因为汇编语言是大学本科课程，所以几乎没人会在实际编程中用的汇编语言也光荣“上榜”</li><li>delphi能排在这么高的位置只能说是因为历史上delphi辉煌了很长一段时间，但现在恐怕找破头都找不到有人用delphi了。或许很多人连这个名字都没听过吧</li><li>Perl现在的应用领域几乎只局限在正则表达式和DSL一块。除非程序需要极大量地进行文本处理，否则现在几乎没人会考虑Perl。随意显然，Perl还能有这么高的排名是因为它在历史上很是辉煌过一段时间，至于现在几乎已经被Python完全代替了</li><li>Prolog虽然排在第20，但实际上是整个榜单中最令人匪夷所思的一个。很难相信这样一门从诞生开始就几乎没有任何人使用的语言能排在第20位。也许是有人开始写文章怀旧Prolog了所以排名才升高？毕竟作为唯一的逻辑式编程语言，Prolog也算是整理编程语言发展史逃不开的话题</li><li>从第20之后，事情就开始变得魔幻了起来。SAS、Scratch、FoxPro等压根不通用的编程语言光荣上榜。Scratch作为教学使用的玩具语言也能上榜甚至排在Kotlin、Rust、Dart、TS前边，足以说明这榜单的魔幻性</li><li>COBOL、Fortran、Ada等老古董考虑到部分工业系统还在使用它们，目前这个排名肯定有一部分历史原因，但应该不算离谱</li><li>……真有人把awk算作一门编程语言？虽说这也是图灵完备的，但更多还是作为工具使用</li><li>Groovy排在TS、Dart这些有实际工程应用的语言前面实在是不太合理。Groovy目前除了配置Gradle恐怕没什么其他作用了。TS排名真的太低了，低到了不合理的地步</li><li>Rust、Julia、Kotlin等新兴语言还算合理</li></ol><p>事实上从目前的情况来看，这些编程语言排名可以说没有任何价值……现在事实上的排名简直太清楚了：Java和JavaScript肯定是前二，至于哪个第一哪个第二还有待讨论；Python考虑到在人工智能、数据科学等领域的广泛应用，排个第三不成问题；C&#x2F;C++、C#、SQL仅次于上面三个，具体排名可以讨论，但位置应该就处在这个水平。在剩下的一些中，Swift、PHP、Go、Lua、Ruby、Rust、Julia、Kotlin、Scala、TypeScript、Dart这些算是目前还有些工程应用的，其中Go、Rust、Kotlin、TS现在稍热一些，至于其他的恐怕只剩下存量，或是根本没几个人在工程里使用了，抑或是压根就是个玩具。SAS、R和MATLAB作为统计学语言论外处理，这三个按理来说就不应该和其他语言放到一起看。</p><p>虽然稍微了解一些编程的人都会把这类榜单当作笑话，但万一真有人当真了，也是挺吓人的一件事。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java仍是最适合学习软件工程的语言</title>
    <link href="/2022/06/29/Java%E4%BB%8D%E6%98%AF%E6%9C%80%E9%80%82%E5%90%88%E5%AD%A6%E4%B9%A0%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E8%AF%AD%E8%A8%80/"/>
    <url>/2022/06/29/Java%E4%BB%8D%E6%98%AF%E6%9C%80%E9%80%82%E5%90%88%E5%AD%A6%E4%B9%A0%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E7%9A%84%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Java仍是最适合学习软件工程的语言"><a href="#Java仍是最适合学习软件工程的语言" class="headerlink" title="Java仍是最适合学习软件工程的语言"></a>Java仍是最适合学习软件工程的语言</h1><p>我承认这标题起得不怎么样。“适合学习”，什么叫做“学习”？如果是为了工作考虑，Java当然值得学习。但这里的“学习”并不是“适合工作”的概念，而是指为整个计算机领域认知体系打下良好基础的“学习”。甚至可以说Java是适合任何一个计算机类专业本科生学习的语言，尤其是软件工程专业。</p><p>近年来，我们似乎常常听到“Java将要没落了”，而且Java的市场份额的确不再增长了。很多人对Java的第一印象就是“啰嗦”，冗长得让人看着就犯恶心。写Java代码确实不是一件让人十分愉快的事情，你不得不编写大量的模板代码，然后将真正的代码逻辑放在一系列既定的框架之中。程序员热爱自由，但Java背叛了程序员。</p><p>看看那些“现代”语言吧：Python、Kotlin、Swift、Ruby、JavaScript（ES6之后）……这里说的“现代”当然不是说它们的出现时间都很近，而是指它们在近些年才开始被广泛使用且备受好评。这些语言无论具体语法如何，都是注重简洁灵活的，程序员可以按照自己喜好的方式编写代码，使用各种不同的方式实现同一种功能。而Java则显得太臃肿、太死板，大多数程序员实现同一种功能都会写出几乎一模一样的代码。</p><p>然而我们看到，任何一本被以“设计模式”作为标题的书，只要标题中没有明确说明使用的是哪门语言，就几乎必然使用Java。在如此多主流语言中，Java是唯一一门完全面向对象的语言，它直接而丑陋地将类结构暴露给用户，而这恰恰造就了以Java作为开发语言的项目往往有着很好的框架结构。Java强迫你以框架的方式思考代码结构，熟悉了Java开发流程后，构建一套自洽的类结构几乎是潜意识行为。大量的工厂类和访问器&#x2F;修改器方法使Java写起来臃肿不堪，但这也使得Java是最容易用类图描述的主流语言。</p><p>“设计模式本质上是为了弥补语言设计时的缺陷。”这句话是非常正确的。若Java中也能自由地将函数当作一等公民对待，那么工厂模式几乎没有任何存在价值。如果Java在语法层面上直接支持访问器与修改器，那么任何以get和set开头的丑陋方法也将不复存在。</p><p>但我们也看到，一门语言的语法越灵活，代码呈现的个人风格也就越强。历史上认为Java语法丑陋而试图简化它的尝试有很多，Groovy、Scala、Kotlin……但它们都只在一些特定领域取代了Java的功能，Scala在大数据处理上获得了一定的成功（Spark），Kotlin在安卓UI开发上获得了成功，而更多语言则死去了，例如目前应用范围几乎只在Gradle配置文件的Groovy。理论上来说，这些替代品都有能力直接对接Java生态，用Scala、Kotlin甚至Clojure实际上都可以写Spring，但现实中这么做的人少之又少。归根结底，Java在目前的实践中仍是最适合团队后端开发的语言。在有少数几个架构师掌控全局的情况下，Java代码的生命周期是很长的。而这些更加灵活的替代性语言更适合小团队或是单人开发……但这种情况下为什么还要用Java生态？</p><p>工程化有两个方向，一种是像Go一样追求极致的简单，一种是像Java一样追求极致的结构化，即使这会使得代码臃肿不堪。而在大学中教学的目的不单单是为了工程，更重要的是教会学生通过系统化方式组织代码的知识，在这种情况下，Java就成了几乎唯一的选择。无怪乎当今高校理论书籍中的示例代码要么是用于演示底层逻辑的C，要么就是Java。</p><p>Java不会在可见的未来死去——即使它是对程序员精神的背叛。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一些关于异常的思考</title>
    <link href="/2022/06/07/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E5%BC%82%E5%B8%B8%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <url>/2022/06/07/%E4%B8%80%E4%BA%9B%E5%85%B3%E4%BA%8E%E5%BC%82%E5%B8%B8%E7%9A%84%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h1 id="一些关于异常的思考"><a href="#一些关于异常的思考" class="headerlink" title="一些关于异常的思考"></a>一些关于异常的思考</h1><p>异常处理是个非常悠久的话题。最初并不存在异常处理，惯常的方式是像C一样，通过不同的返回值标记函数运行的状态。各种语言中常见的返回-1表示不存在的indexOf方法，就是这种方式的遗留。</p><p>后来人们发觉，为了代码的健壮性，很多时候需要在C语言代码中加入大量的if…elseif…判断返回状态，以处理各种各样的错误。于是异常处理出现了，它的目的是将处理异常的代码挪到另一处，而在其他地方不用进行各种复杂的返回值判断，只需要抛出异常即可。</p><p>异常处理最初并不源于某个特定的编程语言，而是源于早期的一批操作系统。异常处理真正被加入编程语言中的时间，已经很难追溯，但从现在看来，较早加入异常的语言之一是C++。尽管如此，C++社区当时主要还是维持着从C留下来的习惯，C++的异常处理时常为人不屑一顾。异常处理真正被编译器集成，应当源于Java。</p><p>Java带来了检查型异常，方法将抛出哪些异常都必须在定义时便说明，这使得编译器就可以对异常进行检查，以实现更为健壮的代码。</p><p>然而人们逐渐发现，在一些情况下，大量的try…catch…嵌套并没有减少代码量，反而看起来比C语言返回状态的方式还冗长得多。而Java的检查型异常更令人难以忍受，尤其是当异常的数量多到一定程度时，许多人宁愿写个空的catch块把异常无视也不乐意去进行处理。同时，异常在程序规模增大时似乎并没有很好地使代码更加健壮，因为人们在异常检查上花费了太多的时间，而这些时间本可以节约下来进行更多的单元测试，这能达到同样的目的。</p><p>然后我们看到，很多函数式语言并不存在异常，它们使用Either来处理类似的问题。Either是个有些特别的数据结构，它近似于<code>Either[left, right]</code>，只包含两个值。当函数出错时，就返回<code>Either[error, null]</code>，左值为异常，右值为空，否则返回<code>Either[null, result]</code>，左值为空，右值为结果。这样一来，就不需要try…catch…块的嵌套，一切变得非常清晰。</p><p>……好吧，这其实回到了原点。Either看起来很好，其实和C语言惯常的返回状态本质上没什么区别。异常的出现就是为了在编写程序的过程中尽可能不考虑可能出现的错误，然后将处理错误的程序独立到单独的代码块中。要使用Either，就需要对每个返回值进行判断，这并没有解决问题。</p><p>而在一些语言中，干脆既不需要Either，也不需要异常。例如Go，函数直接返回两个值，前者是结果，后者是错误，每次使用返回值时都检查一遍是否存在错误（即第二个返回值是否为空）。又如Node.js，其标准库中最初的一批函数全部返回两个值，区别只是第一个是错误，第二个是结果。可以看到，它们显然也没有解决什么问题，还是像最初C语言的思路一样。</p><p>Go的错误处理方式令许多人感到厌恶，因其近乎是强制性地需要程序员每次都考虑错误。而Python就显得友好，你可以当作异常不存在——直到你遇到它。</p><p>但是异常真的那么重要？在TDD模式下，足够的测试似乎已经涵盖了异常，加入大量模板代码处理异常，甚至像Java使用编译器检查异常，似乎只是在做重复工作。Python这样动态的一门语言，仍然能够使用Django开发大型网站后端，只要有足够完善的测试。</p><p>我们是如此厌恶异常，但又不得不处理异常，正如我们总是一团乱麻的生活一样。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Rhyme——在程序语言设计上的一次尝试</title>
    <link href="/2022/05/29/Rhyme%E2%80%94%E2%80%94%E5%9C%A8%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E4%B8%8A%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95/"/>
    <url>/2022/05/29/Rhyme%E2%80%94%E2%80%94%E5%9C%A8%E7%A8%8B%E5%BA%8F%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E4%B8%8A%E7%9A%84%E4%B8%80%E6%AC%A1%E5%B0%9D%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Rhyme——在程序语言设计上的一次尝试"><a href="#Rhyme——在程序语言设计上的一次尝试" class="headerlink" title="Rhyme——在程序语言设计上的一次尝试"></a>Rhyme——在程序语言设计上的一次尝试</h1><p>Rhyme是我设想中的一门新语言，<strong>它现在还没有一个可用的编译器实现</strong>，也仍有许多内容处于设计阶段。Rhyme的初步设想是编译成JavaScript实现，这可能被称为RhymeScript，这也许会在未来几年被实现。我试图将一些我认为很有趣的新想法加入到这一实验性语言中。当然，目前这一想法仅停留于自娱自乐阶段，很多东西非常不严谨，所以也不用太过严肃。</p><p>我这里不会详细描述Rhyme的每一个部分，只是简单提出几点我个人认为很有趣（当然不一定实用的设计），写在这里自娱自乐一下。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>为了直观起见，先贴一点示例（自然是跑不起来的，因为目前这门语言只存在于想象中）：</p><h2 id="核心设计思路"><a href="#核心设计思路" class="headerlink" title="核心设计思路"></a>核心设计思路</h2><ul><li>Rhyme是静态强类型、渐进类型与结构化类型的，这和TypeScript很相似</li><li>Rhyme试图尽可能使得编程像是英文写作，并提供强大的元编程能力最大程度地实现“自然语言编程”，这使得DSL的设计变得非常简单，这和Ruby是类似的；同理，为了尽可能使得代码易读，Rhyme也会使用<code>and</code>、<code>or</code>这些关键字而非<code>&amp;&amp;</code>、<code>||</code></li><li>Rhyme试图尽可能减少程序员的打字负担。因此Rhyme会较常使用简写，例如<code>function</code>被简写成<code>fn</code>，<code>String</code>被简写成<code>Str</code>，<code>Integer</code>被简写成<code>Int</code>等</li><li>在Rhyme中空格的地位被极端强调，所有的二元运算符两边必须加上空格，因此<code>1+1</code>会报错，<code>1+ 1</code>也会报错，只有<code>1 + 1</code>不会。同理，赋值运算符<code>=</code>、乘方运算符<code>^</code>等使用时两边也必须加上空格。除此之外，一元运算符中除了负号必须不带空格使用（例如<code>- 1</code>会报错，而<code>-1</code>不会），其他所有一元运算符必须带上空格使用</li><li>承接上一条，Rhyme对空格的重视不仅限于运算符。例如函数定义时<code>fn</code>关键字与后面的括号之间必须带空格，比如<code>fn() &#123;&#125;</code>会报错，而<code>fn () &#123;&#125;</code>不会。泛型必须和<code>fn</code>后的括号结合，比如<code>fn&lt;T&gt; () &#123;&#125;</code>会报错，而<code>fn &lt;T&gt;()</code>不会。</li><li>对空格的重视使得Rhyme获得以下好处：①代码风格统一；②编译速度快，因为这使得编译器不用再考虑很多二义性问题；③变量命名自由，这使得变量命名可以带<code>-</code>作为连字符而不再被二义性所困扰。</li><li>Rhyme底层采用原型继承，这使得元编程变得更加灵活。不过Rhyme同时也提供class语法糖将底层的原型继承模式隐藏了起来，而且有额外的优化（这甚至更胜于JavaScript ES6加入的class语法糖）。一般来说，当用户不需要使用元编程时，他就不需要了解有关底层原型继承机制的任何知识。</li><li>Rhyme会在编译期进行大量的性能优化，例如单类型的list会有额外的性能优化。</li><li>Rhyme原生对科学计算有很好的支持，标量（Scaler）、向量（Vector）、矩阵（Matrix）及张量（Tensor）这几个数据类型是内置的。同时也对向量化有很好的支持。</li><li>考虑到多数程序员并不经常使用位运算符，但位运算符实质上又诡异地占据了许多语言中那些最宝贵的运算符，因此Rhyme将取消位运算符。当然，位运算本身仍是被保留的，如果确实需要大量使用位运算符，例如嵌入式开发，可以通过其他方式重新引入位运算符。</li><li>Rhyme的所有语句按理来说都不需要在末尾加上分号，不过这仍是可选的。Rhyme会按照换行符尽可能解析代码直到其不能解析为止，类似JavaScript，不过当一行以<code>(</code>、<code>[</code>、<code>+</code>等符号开头时，Rhyme会强制将其视作新一行代码，这是与JavaScript不同的。</li><li>Rhyme没有<code>new</code>关键字，所有的类都可以直接创建实例，Rhyme选择相信程序员。</li><li>Rhyme拥抱函数式编程，鼓励尽可能使用<code>foreach/map/filter/reduce</code>等函数而非使用for循环。同时Rhyme不提供类似<code>fn fnName () &#123;&#125;</code>的函数定义方式，只提供<code>const/let fnName = fn () &#123;&#125;</code>的函数定义方式（或是<code>const/let fnName = () =&gt; &#123;&#125;</code>）。甚至类定义也是如此，只提供类似<code>const/let className = class () &#123;&#125;</code>的定义方式。自然，只有这类函数&#x2F;类定义方式的Rhyme不存在函数&#x2F;类作用域提升。</li></ul><p>好了，枯燥的文字到此结束了，下面谈谈一些存在于我设想中的有趣设计。</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>在Rhyme中，运算符的定义被极大扩展。运算符可以是一元或二元的，一元运算符只能是前置运算符。用户自定义运算符的优先级永远是最低的，这可以防止一些意料之外的问题。所有运算符调用时都必须在两边加上空格，只有取负运算符<code>-</code>是例外，它必须不加空格调用。</p><p>多说无益，直接上代码。由于Rhyme尽量以“自然语言编程”的设计哲学，因此Rhyme中应当不会加入管道运算符<code>|&gt;</code>，但通过自定义运算符，用户可以轻松实现它：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-variable constant_">IKWID</span> &#123;<br>  <span class="hljs-title class_">Object</span>.|&gt; = op &lt;T, U&gt;(self, <span class="hljs-attr">f</span>: <span class="hljs-function"><span class="hljs-params">T</span> =&gt;</span> U) -&gt; U &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">f</span>(self)<br>  &#125;<br>&#125;<br><br><span class="hljs-number">1</span> |&gt; <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + <span class="hljs-number">1</span> |&gt; <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x ^ <span class="hljs-number">2</span> <span class="hljs-comment">// =&gt; 4</span><br></code></pre></td></tr></table></figure><p>在上面的代码中，<code>IKWID</code>是”I Know What I’m Doing”的缩写。当用户尝试进行危险操作，例如直接修改内置类时，需要将代码放在<code>IKWID</code>块中。</p><p>在Ruby中，<code>2.days.ago</code>是吸引人入坑的一大特色，在Rhyme中甚至可以更好地实现它：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-variable constant_">IKWID</span> &#123;<br>  <span class="hljs-title class_">Number</span>.<span class="hljs-property">days</span> = op &lt;T, E&gt;(self, <span class="hljs-attr">rhs</span>: <span class="hljs-title class_">Symbol</span>) -&gt; <span class="hljs-title class_">Either</span>&lt;T, E&gt; =&gt; &#123;<br>    <span class="hljs-keyword">if</span> rhs == :ago &#123;<br>      <span class="hljs-keyword">return</span> datetime.<span class="hljs-title function_">now</span>() - self * <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> rhs == :later &#123;<br>      <span class="hljs-keyword">return</span> datetime.<span class="hljs-title function_">now</span>() + self * <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span><br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;operator &quot;days&quot; must be called with &quot;ago&quot; or &quot;later&quot;&#x27;</span>)<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 假设当前时间为2022-03-19 01:15:52</span><br><span class="hljs-keyword">const</span> t = <span class="hljs-number">2</span> days ago<br><span class="hljs-title function_">print</span>(t) <span class="hljs-comment">// =&gt; 2022-03-17 01:15:52</span><br></code></pre></td></tr></table></figure><p>上述代码将”days”定义为了一个在num类型上使用的运算符，它只接受一个值为”ago”或”later”的Symbol作为右值，返回n天前&#x2F;后的时间。</p><p>可以看到，运算符某种意义上可以视作接收一个或两个参数的函数的另一种形式。因此，普通的函数如果接收一个或两个参数，也可以通过这种方式调用，只需加上一个装饰器，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">const</span> add = <span class="hljs-meta">@operator</span> (<span class="hljs-attr">lhs</span>: num, <span class="hljs-attr">rhs</span>: num) =&gt; lhs + rhs<br><br><span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// =&gt; 3</span><br><span class="hljs-number">1</span> add <span class="hljs-number">2</span>   <span class="hljs-comment">// =&gt; 3</span><br></code></pre></td></tr></table></figure><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>虽然在Rhyme中无法直接通过<code>fn fnName () &#123;&#125;</code>定义函数，但可以在<code>const/let fnName = fn () &#123;&#125;</code>中加上可选的函数名，例如<code>const/let fnName = fn fnName () &#123;&#125;</code>，这主要是为了方便递归。不过通常来说，不必为函数标上函数名，而且即使不标函数名Rhyme也会对报错信息进行优化。</p><p>Rhyme中定义匿名函数的形式多种多样。上面已经演示过的<code>fn</code>和箭头函数就不展示了，这里展示一下通过<code>it</code>关键字定义的匿名函数。显然，该灵感来自于Clojure。</p><p>先看下面这段代码：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>] filter #&#123;it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>&#125; <span class="hljs-comment">// =&gt; [2, 4]</span><br></code></pre></td></tr></table></figure><p>显然，可以看到<code>filter</code>应当已经被定义在列表类型上的运算符，其右值接收一个函数作为参数，而这里的<code>#&#123;it % 2 == 0&#125;</code>就是这个被接收的函数。</p><p>一个由<code>#&#123;&#125;</code>包裹的代码块会被视为一个匿名函数，而<code>it</code>就表示该函数接收的参数。当仅接收一个参数时，<code>it</code>很自然地就表示那个唯一的参数；当接收多个参数时，<code>it</code>表示一个包含多个参数的元组，可以通过<code>it[0]</code>、<code>it[1]</code>等调用这些参数。</p><p>有时，包裹it匿名函数的<code>#&#123;&#125;</code>可以省略，例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].<span class="hljs-title function_">filter</span>(it % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-comment">// =&gt; [2, 4]</span><br></code></pre></td></tr></table></figure><p>仅当其作为函数参数时能够省略<code>#&#123;&#125;</code>。此外省略形式的匿名函数不能包含逗号，逗号将截断表达式并将其视作两个参数。不过，如<code>div(a, b) == 0</code>这样的代码不会有问题。</p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>Rhyme不提供<code>|&gt;</code>作为管道操作符，因为这不符合“自然语言编程”的设计思路。但Rhyme以其他方式提供管道操作。</p><p>在Rhyme中，管道操作通过.then方法实现。该方法存在于Object对象上：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">const</span> x = <span class="hljs-number">1</span><br><span class="hljs-keyword">const</span> result = x<br>  .<span class="hljs-title function_">then</span>(it + <span class="hljs-number">1</span>)<br>  .<span class="hljs-title function_">then</span>(it * <span class="hljs-number">2</span>)<br>  .<span class="hljs-title function_">then</span>(it ^ <span class="hljs-number">2</span>)<br>x       <span class="hljs-comment">// =&gt; 1</span><br>result  <span class="hljs-comment">// =&gt; 8</span><br></code></pre></td></tr></table></figure><p>值得注意的是，这里的.then()是同步的，它只是用于表示管道操作的方法，与JavaScript中的Promise没有任何关系。</p><p>当然，自定义一个全局的<code>|&gt;</code>运算符也没什么问题：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-variable constant_">IKWID</span> &#123;<br>  <span class="hljs-title class_">Object</span>.|&gt; = op &lt;T, U&gt;(self, <span class="hljs-attr">f</span>: <span class="hljs-function"><span class="hljs-params">T</span> =&gt;</span> U) -&gt; <span class="hljs-function"><span class="hljs-params">U</span> =&gt;</span> <span class="hljs-title function_">f</span>(self)<br>&#125;<br></code></pre></td></tr></table></figure><p>Rhyme并不禁止为内置对象添加属性，这意味着程序员可以直接更改内置API。然而，当进行类似的修改时，Rhyme的编译器会发出警告，以确保你确实知道自己在做什么，因此上面使用了<code>@suppress-warning</code>装饰器来抑制警告。</p><p>然后，你就可以轻松地使用管道运算符了：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">const</span> x = <span class="hljs-number">1</span><br><span class="hljs-keyword">const</span> result = x |&gt; #&#123; it + <span class="hljs-number">1</span> &#125; |&gt; #&#123; it * <span class="hljs-number">1</span> &#125; |&gt; #&#123; it ^ <span class="hljs-number">2</span> &#125;<br>x       <span class="hljs-comment">// =&gt; 1</span><br>result  <span class="hljs-comment">// =&gt; 8</span><br></code></pre></td></tr></table></figure><p>当然，由于这不太符合Rhyme的设计哲学，因此建议使用.then()方法，而不是自定义的管道运算符。这里仅做演示用。</p><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><p>在Rhyme中，空格是有意义的，并且无论什么情况下都不可省略。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span><br><span class="hljs-keyword">let</span> b =<span class="hljs-number">10</span> <span class="hljs-comment">// !SyntaxError</span><br></code></pre></td></tr></table></figure><p>空格以外的空白字符是可以省略的，例如换行。Rhyme在编译时会智能为行末加上<code>;</code>，参考JavaScript。然而，不同于JavaScript的是，当下一行以<code>()[]</code>及运算符开头时，Rhyme会直接在上一行的末尾加上<code>;</code>。</p><p>Rhyme对空格的严格限制远不仅限于此。有些限制似乎毫无必要，例如要求在<code>fn</code>关键字后加上空格，这甚至与多数人的习惯相悖。然而严格限制空格带来很多好处，例如更好的编译效率、更自由的变量命名（例如可使用<code>-</code>连字符），这也能强制所有Rhyme代码维持相对统一的代码规范。</p><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p>在Rhyme中，模式匹配使用switch…case…语句实现。需要注意的是，Rhyme中不存在<code>fallthrough</code>语法，因此不需要写break。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">match letter &#123;<br>  <span class="hljs-string">&#x27;a&#x27;</span> | <span class="hljs-string">&#x27;e&#x27;</span> | <span class="hljs-string">&#x27;i&#x27;</span> | <span class="hljs-string">&#x27;o&#x27;</span> | <span class="hljs-string">&#x27;u&#x27;</span> -&gt; &#123;<br>    <span class="hljs-title function_">println</span>(<span class="hljs-string">&#x27;Vowel&#x27;</span>)<br>  &#125;<br>  <span class="hljs-string">&#x27;y&#x27;</span> | <span class="hljs-string">&#x27;w&#x27;</span> -&gt; &#123;<br>    <span class="hljs-title function_">println</span>(<span class="hljs-string">&#x27;Sometimes Vowel&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">default</span> -&gt; &#123;<br>    <span class="hljs-title function_">println</span>(<span class="hljs-string">&#x27;consonant&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>与许多语言一样，Rhyme同样使用class关键字进行类定义。通过class关键字定义的类名不得以小写字母开头，若用下划线开头，则在若干下划线之后的第一个非下划线字符不得是小写字母或数字。不过，Rhyme并不限制其他Unicode字符，例如使用中文命名类名，这将没有大小写字母的限制。</p><p>值得注意的是，Rhyme直接使用方法的第一个参数区分实例方法、类方法以及静态方法。若第一个参数为<code>self</code>，则认为该方法为实例方法；若第一个参数为<code>cls</code>，则认为该方法为类方法；否则认为该方法为静态方法。因此，在Rhyme中<code>self</code>和<code>cls</code>为保留字。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Point</span> = <span class="hljs-keyword">class</span> (restricted <span class="hljs-attr">x</span>: num, restricted <span class="hljs-attr">y</span>: num) &#123;&#125;<br><br><span class="hljs-keyword">const</span> point1 = <span class="hljs-title class_">Point</span>() <span class="hljs-comment">// Error</span><br><span class="hljs-keyword">const</span> point1 = <span class="hljs-title class_">Point</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-keyword">const</span> point2 = <span class="hljs-title class_">Point</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><p>Rhyme提供抽象类和特性（trait）。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Person</span> = abs <span class="hljs-keyword">class</span> (...) &#123;<br>  <span class="hljs-comment">// 不能实例化</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Human</span> = trait &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>同许多语言一样，类支持继承（且支持多重继承，使用线性化实现）。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Teacher</span> = <span class="hljs-keyword">class</span> (...) &lt; <span class="hljs-title class_">Person</span>, <span class="hljs-title class_">Human</span> &#123;<br>  <span class="hljs-comment">// 继承</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Rhyme强制规定继承时，trait必须放在class之后，否则无法通过编译。</p><p>另外，实际上由于Rhyme使用鸭子类型，因此显式继承trait是可选的，但仍推荐这么做。当声明继承某个trait的类被发现未实现trait中规定的某些方法时，将编译失败。</p><p>类本质上仍是对象，因此支持动态修改。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-title class_">Point</span>.<span class="hljs-property">distanceTo</span> = (self, <span class="hljs-attr">point</span>: <span class="hljs-title class_">Point</span>) -&gt; <span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> ((self.<span class="hljs-property">x</span> - point.<span class="hljs-property">x</span>) ^ <span class="hljs-number">2</span> + (self.<span class="hljs-property">y</span> - point.<span class="hljs-property">y</span>) ^ <span class="hljs-number">2</span>) ^ <span class="hljs-number">0.5</span><br>&#125; <span class="hljs-comment">// 需要注意的是，如果没有template，创建的是静态方法（类方法），而非实例方法</span><br><br>point1.<span class="hljs-title function_">distanceTo</span>(point2) <span class="hljs-comment">// =&gt; 2.8284271247461903</span><br><br><span class="hljs-title class_">Point</span>.<span class="hljs-property">__options__</span>.<span class="hljs-property">extensible</span> = <span class="hljs-literal">false</span> <span class="hljs-comment">// 当然也支持禁止这一特性</span><br></code></pre></td></tr></table></figure><p>在默认情况下，一个通过class创建的类是支持动态修改的，然而这可能造成原型链污染。如果对此感到厌恶，可以在配置文件里将其关掉。</p><p>下面演示Range类的实现：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Range</span> = <span class="hljs-keyword">class</span> (<br>  <span class="hljs-attr">start</span>: num,<br>  <span class="hljs-attr">end</span>: num,<br>  <span class="hljs-attr">step</span>: num = <span class="hljs-number">1</span><br>) &#123;<br>  def current = start - step<br><br>  ovld init = <span class="hljs-function">(<span class="hljs-params">self, end: num</span>) =&gt;</span> &#123;<br>    self.<span class="hljs-title function_">init</span>(<span class="hljs-number">0</span>, end, <span class="hljs-number">1</span>)<br>  &#125;<br><br>  def __iter__ = <span class="hljs-function"><span class="hljs-params">self</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> self<br>  &#125;<br><br>  def __next__ = <span class="hljs-function"><span class="hljs-params">self</span> =&gt;</span> &#123;<br>    self.<span class="hljs-property">current</span> += self.<span class="hljs-property">step</span><br>    <span class="hljs-keyword">if</span> self.<span class="hljs-property">current</span> &gt;= self.<span class="hljs-property">end</span> &#123;<br>      raise <span class="hljs-title class_">IterationEndError</span>()<br>    &#125;<br>    <span class="hljs-keyword">return</span> self.<span class="hljs-property">current</span><br>  &#125;<br>  <br>  def range = <span class="hljs-function">(<span class="hljs-params">cls, start: num, end: num, step: num = <span class="hljs-number">1</span></span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">cls</span>(start, end, step)<br>  &#125;<br>  <br>  ovld range = <span class="hljs-function">(<span class="hljs-params">cls, end: num</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">cls</span>(end)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在类定义中只能包含<code>def</code>、<code>ovld</code>（重载）和<code>ovrd</code>（重写）语句，<code>def</code>可以用来定义属性或方法，它们本质上没什么不同。此外，Rhyme使用不同前缀区分私有（<code>_</code>）、公有（默认）和受保护（<code>#</code>）。</p><p>Rhyme并不认为继承有什么坏处，甚至也不禁止多重继承，因为这是一种很直接的思维方式。继承产生问题的根源在于滥用继承的人身上，而不在于继承本身。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
